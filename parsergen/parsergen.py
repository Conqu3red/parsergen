"""Creates GeneratedParser's from the given grammar

Resources:
    https://youtu.be/QppWTvh7_sI
    https://en.wikipedia.org/wiki/Parsing_expression_grammar
    https://medium.com/@gvanrossum_83706/peg-parsing-series-de5d41b2ed60

"""
from typing import *

from .lexer import TokenStream
from .parser import Expr, ExprList, GrammarLexer, GrammarParser, NamedItem, OneOrMore, OrOp, Statement, StatementPointer, TokenPointer, ZeroOrMore, ZeroOrOne, format_grammar
from pprint import pprint
from contextlib import contextmanager

class Filler:
    def __repr__(self) -> str:
        return "Filler()"

class Node:
    def __init__(self, type, children: list) -> None:
        self.type = type
        self.children = children
    
    def __repr__(self) -> str:
        return f"Node({self.type!r}, {self.children!r})"

def memoize(func):
    def memoize_wrapper(self, *args):
        pos = self.mark()
        memo = self.memos
        key = (pos, func, args)
        if key in memo:
            res, endpos = memo[key]
            self.goto(endpos)
        else:
            res = func(self, *args)
            endpos = self.mark()
            memo[key] = res, endpos
        return res
    return memoize_wrapper


def memoize_left_rec(func):
    # https://github.com/PhilippeSigaud/Pegged/wiki/Left-Recursion
    def memoize_left_rec_wrapper(self, *args):
        pos = self.mark()
        memo = self.memos
        key = (pos, func, args)
        if key in memo:
            res, endpos = memo[key]
            self.goto(endpos)
        else:
            # Prime the cache with a failure.
            memo[key] = lastres, lastpos = None, pos
            # Loop until no longer parse is obtained.
            while True:
                self.goto(pos)
                res = func(self, *args)
                endpos = self.mark()
                if endpos <= lastpos:
                    break
                memo[key] = lastres, lastpos = res, endpos
            res = lastres
            self.goto(lastpos)
        return res
    return memoize_left_rec_wrapper


class GeneratedParser:
    _or = lambda _, a, b: a or b

    def __init__(self, token_stream: TokenStream) -> None:
        self.memos = {}
        self.token_stream = token_stream
    
    def mark(self):
        return self.token_stream.mark()
    
    def goto(self, pos):
        self.token_stream.goto(pos)
    
    @memoize
    def expect(self, type):
        tok = self.peek_token()
        if tok.type == type:
            self.token_stream.pos += 1
            return tok
        return None
    
    def peek_token(self):
        return self.token_stream.peek_token()
    
    def match(self, part):
        if isinstance(part, list):
            for p in part:
                if isinstance(p, list):
                    if not self.match(p):
                        return False
                elif not p:
                    return False
        elif not part:
            return False
        return True


HEADER = """# Code @generated by parsergen; do not edit!
from parsergen.parsergen import GeneratedParser, TokenStream, Node, Filler
from parsergen.parsergen import memoize, memoize_left_rec
from functools import reduce

"""

class Generator:
    def __init__(self) -> None:
        self.result = ""
        self._indent = 0
        self.counter = 0
        self.queue = []
    
    def push(self, line: str):
        self.result += (self._indent * "    ") + line + "\n"
    
    @contextmanager
    def indent(self):
        saved = self._indent
        try:
            self._indent += 1
            yield
        finally:
            self._indent = saved
    
    def is_left_recursive(self, stmts: List[Statement]):
        # BUG: Implement this function! 
        # Currently aways returns True
        #for stmt in stmts:
        #    if isinstance(stmt.grammar[0], StatementPointer) and stmt.grammar[0].target == stmt.name:
        #        return True
        #return False
        return True

    def generate(self, grammar: str):
        rules = {}
        gl = GrammarLexer()
        gp = GrammarParser()
        rules_list = gp.parse_all(gl.lex_string(grammar).tokens)
        for r in rules_list:
            if r.name in rules:
                rules[r.name].append(r)
            else:
                rules[r.name] = [r]

        pprint(rules)
        print(format_grammar(rules))
        return self.generate_parser_class(rules)

    def generate_parser_class(self, grammar: Dict[str, List[Statement]]):
        
        self.push(f"class TempParser(GeneratedParser):")
        with self.indent():
            for name, stmts in grammar.items():
                if self.is_left_recursive(stmts):
                    self.push(f"@memoize_left_rec")
                else:
                    self.push(f"@memoize")
                self.push(f"def {name}(self):")
                queue = []
                with self.indent():
                    self.push(f"pos = self.mark()")
                    for stmt in stmts:
                        self.gen_statement(stmt, queue)
                    self.push(f"return None\n")
                self.resolve_queue(queue)
        return HEADER + self.result
    
    def gen_statement(self, stmt: Statement, queue):
        self.push("parts = [")
        named_items = []
        with self.indent():
            for c, item in enumerate(stmt.grammar):
                if isinstance(item, NamedItem):
                    named_items.append((c, item))
                    item = item.expr
                self.gen(item, queue)
        self.push("]")
        self.push("if self.match(parts):")
        with self.indent():
            for c, named_item in named_items:
                self.push(f"{named_item.name} = parts[{c}]")
            if stmt.action:
                self.push(f"return {stmt.action}")
            else:
                self.push(f"return Node({stmt.name!r}, parts)")
        self.push(f"self.goto(pos)\n")
    
    def gen(self, item: Expr, queue):
        return getattr(self, f"gen_{type(item).__name__}")(item, queue)
    
    #def construct(self, f: str, args: List[str]):
    #    return f"{f}({', '.join(repr(arg) for arg in args)})"
    
    def gen_TokenPointer(self, item: TokenPointer, queue):
        self.push(f"self.expect({item.target!r}),")
    
    def gen_StatementPointer(self, item: StatementPointer, queue):
        self.push(f"self.{item.target}(),")

    
    def gen_ZeroOrMore(self, item: ZeroOrMore, queue):
        queue.append((item, self.counter))
        self.push(f"self._loop_{self.counter}(),")
        self.counter += 1
    
    def gen_OneOrMore(self, item: OneOrMore, queue):
        queue.append((item, self.counter))
        self.push(f"self._loop_{self.counter}(),")
        self.counter += 1
    
    def gen_ZeroOrOne(self, item: ZeroOrOne, queue):
        queue.append((item, self.counter))
        self.push(f"self._maybe_{self.counter}(),")
        self.counter += 1
    
    def gen_OrOp(self, item: OrOp, queue):
        self.push("reduce(")
        with self.indent():
            self.push("self._or,")
            self.push("[")
            with self.indent():
                for choice in item.exprs:
                    self.gen(choice, queue)
            self.push("]")
        self.push(")")

    def gen_ExprList(self, item: ExprList, queue):
        queue.append((item, self.counter))
        self.push(f"self._expr_list_{self.counter}(),")
        self.counter += 1
    
    def resolve(self, item: Expr, c, queue):
        return getattr(self, f"resolve_{type(item).__name__}")(item, c, queue)
    
    def resolve_ZeroOrMore(self, item: ZeroOrMore, c, queue):
        self.push(f"def _loop_{c}(self):")
        with self.indent():
            self.push("children = []")
            self.push("while True:")
            with self.indent():
                self.push("pos = self.mark()")
                self.push("part = (")
                with self.indent():
                    self.gen(item.expr, queue)
                self.push(")[0]")
                self.push("if self.match(part): children.append(part)")
                self.push("else:")
                with self.indent():
                    self.push("self.goto(pos)")
                    self.push("break")
            self.push(f"return children")
    
    def resolve_OneOrMore(self, item: OneOrMore, c, queue):
        self.push(f"def _loop_{c}(self):")
        with self.indent():
            self.push("children = []")
            self.push("while True:")
            with self.indent():
                self.push("pos = self.mark()")
                self.push("part = (")
                with self.indent():
                    self.gen(item.expr, queue)
                self.push(")[0]")
                self.push("if self.match(part): children.append(part)")
                self.push("else:")
                with self.indent():
                    self.push("self.goto(pos)")
                    self.push("break")
            self.push("return children if len(children) > 0 else None")
    
    def resolve_ZeroOrOne(self, item: ZeroOrOne, c, queue):
        self.push(f"def _maybe_{c}(self):")
        with self.indent():
            self.push("pos = self.mark()")
            self.push("part = (")
            with self.indent():
                self.gen(item.expr, queue)
            self.push(")[0]")
            self.push("return part if self.match(part) else Filler()")
    
    def resolve_ExprList(self, item: ExprList, c, queue):
        self.push(f"def _expr_list_{c}(self):")
        with self.indent():
            self.push("pos = self.mark()")
            self.push("parts = [")
            with self.indent():
                for part in item.exprs:
                    self.gen(part, queue)
            self.push("]")
            self.push("if self.match(parts): return parts")
            self.push("self.goto(pos)")
            self.push("return None")

    def resolve_queue(self, queue):
        for item, c in queue:
            q = []
            self.resolve(item, c, q)
            if len(q) > 0:
                self.resolve_queue(q)


